<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net.Contrib.Highlighter</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Search.Highlight.DefaultEncoder">
            <summary>Simple <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> implementation that does not modify the output</summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IEncoder">
            <summary>Encodes original text. The IEncoder works with the Formatter to generate the output.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IEncoder.EncodeText(System.String)">
            <param name="originalText">The section of text being output</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IFormatter">
            <summary> Processes terms found in the original text, typically by applying some form 
            of mark-up to highlight terms in HTML search results pages.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IFormatter.HighlightTerm(System.String,Lucene.Net.Search.Highlight.TokenGroup)">
            <param name="originalText">The section of text being considered for markup</param>
            <param name="tokenGroup">contains one or several overlapping Tokens along with
            their scores and positions.</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IFragmenter">
            <summary> Implements the policy for breaking text into multiple fragments for consideration
            by the <see cref="T:Lucene.Net.Search.Highlight.Highlighter"/> class. A sophisticated implementation may do this on the basis
            of detecting end of sentences in the text. 
            </summary>
            <author>  mark@searcharea.co.uk
            </author>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)">
             <summary>
             Initializes the Fragmenter. You can grab references to the Attributes you are
             interested in from tokenStream and then access the values in {@link #isNewFragment()}.
             </summary>
             <param name="originalText">the original source text</param>
            <param name="tokenStream">tokenStream the <see cref="T:Lucene.Net.Analysis.TokenStream"/> to be fragmented</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IFragmenter.IsNewFragment">
            <summary>
            Test to see if this token from the stream should be held in a new
            TextFragment. Every time this is called, the TokenStream
            passed to start(String, TokenStream) will have been incremented.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.GradientFormatter">
            <summary>
            Formats text with different color intensity depending on the score of the term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.GradientFormatter.#ctor(System.Single,System.String,System.String,System.String,System.String)">
            <summary> Sets the color range for the IDF scores</summary>
            <param name="maxScore">
            The score (and above) displayed as maxColor (See QueryScorer.getMaxWeight 
            which can be used to callibrate scoring scale)
            </param>
            <param name="minForegroundColor">
            The hex color used for representing IDF scores of zero eg
            #FFFFFF (white) or null if no foreground color required
            </param>
            <param name="maxForegroundColor">
            The largest hex color used for representing IDF scores eg
            #000000 (black) or null if no foreground color required
            </param>
            <param name="minBackgroundColor">
            The hex color used for representing IDF scores of zero eg
            #FFFFFF (white) or null if no background color required
            </param>
            <param name="maxBackgroundColor">
            The largest hex color used for representing IDF scores eg
            #000000 (black) or null if no background color required
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.GradientFormatter.HexToInt(System.String)">
            <summary> Converts a hex string into an int. Integer.parseInt(hex, 16) assumes the
            input is nonnegative unless there is a preceding minus sign. This method
            reads the input as twos complement instead, so if the input is 8 bytes
            long, it will correctly restore a negative int produced by
            Integer.toHexString() but not neccesarily one produced by
            Integer.toString(x,16) since that method will produce a string like '-FF'
            for negative integer values.
            
            </summary>
            <param name="hex">
            A string in capital or lower case hex, of no more then 16
            characters.
            </param>
            <exception cref="T:System.FormatException">if the string is more than 16 characters long, or if any
            character is not in the set [0-9a-fA-f]</exception>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.Highlighter">
            <summary>
            Class used to markup highlighted terms found in the best sections of a
            text, using configurable <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/>, <see cref="T:Lucene.Net.Search.Scorer"/>, <see cref="T:Lucene.Net.Search.Highlight.IFormatter"/>,
            <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> and tokenizers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragment(Lucene.Net.Analysis.Analyzer,System.String,System.String)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant section.
            This is a convenience method that calls <see cref="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragment(Lucene.Net.Analysis.TokenStream,System.String)"/>
            </summary>
            <param name="analyzer">the analyzer that will be used to split <c>text</c> into chunks</param>
            <param name="fieldName">Name of field used to influence analyzer's tokenization policy</param>
            <param name="text">text to highlight terms in</param>
            <returns>highlighted text fragment or null if no terms found</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's endOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragment(Lucene.Net.Analysis.TokenStream,System.String)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant section.
            The document text is analysed in chunks to record hit statistics
            across the document. After accumulating stats, the fragment with the highest score
            is returned
            </summary>
            <param name="tokenStream">
            a stream of tokens identified in the text parameter, including offset information.
            This is typically produced by an analyzer re-parsing a document's
            text. Some work may be done on retrieving TokenStreams more efficiently
            by adding support for storing original text position data in the Lucene
            index but this support is not currently available (as of Lucene 1.4 rc2).
            </param>
            <param name="text">text to highlight terms in</param>
            <returns>highlighted text fragment or null if no terms found</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's endOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.Analyzer,System.String,System.String,System.Int32)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant sections.
            This is a convenience method that calls <see cref="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Int32)"/>
            </summary>
            <param name="analyzer">the analyzer that will be used to split <c>text</c> into chunks</param>
            <param name="fieldName">the name of the field being highlighted (used by analyzer)</param>
            <param name="text">text to highlight terms in</param>
            <param name="maxNumFragments">the maximum number of fragments.</param>
            <returns>highlighted text fragments (between 0 and maxNumFragments number of fragments)</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's endOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Int32)">
            <summary>
            Highlights chosen terms in a text, extracting the most relevant sections.
            The document text is analysed in chunks to record hit statistics
            across the document. After accumulating stats, the fragments with the highest scores
            are returned as an array of strings in order of score (contiguous fragments are merged into
            one in their original order to improve readability)
            </summary>
            <param name="tokenStream"></param>
            <param name="text">text to highlight terms in</param>
            <param name="maxNumFragments">the maximum number of fragments.</param>
            <returns>highlighted text fragments (between 0 and maxNumFragments number of fragments)</returns>
            <exception cref="T:Lucene.Net.Search.Highlight.InvalidTokenOffsetsException">thrown if any token's endOffset exceeds the provided text's length</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestTextFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Boolean,System.Int32)">
            <summary>
            Low level api to get the most relevant (formatted) sections of the document.
            This method has been made public to allow visibility of score information held in TextFragment objects.
            Thanks to Jason Calabrese for help in redefining the interface.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.MergeContiguousFragments(Lucene.Net.Search.Highlight.TextFragment[])">
            <summary>
            Improves readability of a score-sorted list of TextFragments by merging any fragments
            that were contiguous in the original text into one larger fragment with the correct order.
            This will leave a "null" in the array entry for the lesser scored fragment. 
            </summary>
            <param name="frag">An array of document fragments in descending score</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.Highlighter.GetBestFragments(Lucene.Net.Analysis.TokenStream,System.String,System.Int32,System.String)">
            <summary>
            Highlights terms in the  text , extracting the most relevant sections
            and concatenating the chosen fragments with a separator (typically "...").
            The document text is analysed in chunks to record hit statistics
            across the document. After accumulating stats, the fragments with the highest scores
            are returned in order as "separator" delimited strings.
            </summary>
            <param name="tokenStream"></param>
            <param name="text">text to highlight terms in</param>
            <param name="maxNumFragments">the maximum number of fragments.</param>
            <param name="separator">the separator used to intersperse the document fragments (typically "...")</param>
            <returns>highlighted text</returns>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.NullFragmenter">
            <summary> <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/> implementation which does not fragment the text.
            This is useful for highlighting the entire content of a document or field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.QueryScorer">
            <summary>
             <see cref="T:Lucene.Net.Search.Highlight.IScorer"/> implementation which scores text fragments by the number of
             unique query terms found. This class converts appropriate <see cref="T:Lucene.Net.Search.Query"/>s to
             <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/>s and attempts to score only those terms that participated in
             generating the 'hit' on the document.
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.IScorer">
            <summary> Adds to the score for a fragment based on its tokens</summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IScorer.Init(Lucene.Net.Analysis.TokenStream)">
             <summary>
             Called to init the Scorer with a {@link TokenStream}. You can grab references to
             the attributes you are interested in here and access them from {@link #getTokenScore()}.
             </summary>
             <param name="tokenStream">the {@link TokenStream} that will be scored.</param>
             <returns>
             either a {@link TokenStream} that the Highlighter should continue using (eg
             if you read the tokenSream in this method) or null to continue
             using the same {@link TokenStream} that was passed in.
             </returns> 
             <exception cref="T:System.IO.IOException"></exception>
            
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IScorer.StartFragment(Lucene.Net.Search.Highlight.TextFragment)">
            <summary>
            Called when a new fragment is started for consideration.
            </summary>
            <param name="newFragment">the fragment that will be scored next</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore">
            <summary>
            Called for each token in the current fragment. The {@link Highlighter} will
            increment the {@link TokenStream} passed to init on every call.
            </summary>
            <returns>a score which is passed to the {@link Highlighter} class to influence the
            mark-up of the text (this return value is NOT used to score the
            fragment)</returns> 
        </member>
        <member name="P:Lucene.Net.Search.Highlight.IScorer.FragmentScore">
            <summary>
             Called when the {@link Highlighter} has no more tokens for the current fragment -
             the Scorer returns the weighting it has derived for the most recent
             fragment, typically based on the results of {@link #getTokenScore()}.
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Constructs a new QueryScorer instance
            </summary>
            <param name="query">Query to use for highlighting</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,System.String)">
            <summary>
            Constructs a new QueryScorer instance
            </summary>
            <param name="query">Query to use for highlighting</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Constructs a new QueryScorer instance
            </summary>
            <param name="query">Query to use for highlighting</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> to use for quasi tf/idf scoring</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String,System.String)">
            <summary>
            Constructs a new QueryScorer instance
            </summary>
            <param name="query">Query to use for highlighting</param>
            <param name="reader"><see cref="T:Lucene.Net.Index.IndexReader"/> to use for quasi tf/idf scoring</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
            <param name="defaultField">The default field for queries with the field name unspecified</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Query,System.String,System.String)">
            <summary>
            Constructs a new QueryScorer instance
            </summary>
            <param name="query">Query to use for highlighting</param>
            <param name="field">Field to highlight - pass null to ignore fields</param>
            <param name="defaultField">The default field for queries with the field name unspecified</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.#ctor(Lucene.Net.Search.Highlight.WeightedSpanTerm[])">
            <summary>
            Constructs a new QueryScorer instance
            </summary>
            <param name="weightedTerms">an array of pre-created <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.GetTokenScore">
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.GetTokenScore"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.Init(Lucene.Net.Analysis.TokenStream)">
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.Init(Lucene.Net.Analysis.TokenStream)"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.GetWeightedSpanTerm(System.String)">
            <summary>
            Retrieve the <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/> for the specified token. Useful for passing
            Span information to a <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/>.
            </summary>
            <param name="token">token to get {@link WeightedSpanTerm} for</param>
            <returns>WeightedSpanTerm for token</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.StartFragment(Lucene.Net.Search.Highlight.TextFragment)">
            <seealso cref="M:Lucene.Net.Search.Highlight.IScorer.StartFragment(Lucene.Net.Search.Highlight.TextFragment)"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryScorer.SetWrapIfNotCachingTokenFilter(System.Boolean)">
            <summary>
            By default, <see cref="T:Lucene.Net.Analysis.TokenStream"/>s that are not of the type
            <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> are wrapped in a <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> to
            ensure an efficient reset - if you are already using a different caching
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> impl and you don't want it to be wrapped, set this to
            false.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryScorer.FragmentScore">
            <seealso cref="P:Lucene.Net.Search.Highlight.IScorer.FragmentScore"/>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryScorer.MaxTermWeight">
            <summary>
            The highest weighted term (useful for passing to GradientFormatter to set top end of coloring scale).
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.QueryScorer.IsExpandMultiTermQuery">
            <summary>
            Controls whether or not multi-term queries are expanded
            against a <see cref="T:Lucene.Net.Index.Memory.MemoryIndex"/> <see cref="T:Lucene.Net.Index.IndexReader"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.QueryTermExtractor">
            <summary> Utility class used to extract the terms used in a query, plus any weights.
            This class will not find terms for MultiTermQuery, RangeQuery and PrefixQuery classes
            so the caller must pass a rewritten query (see Query.rewrite) to obtain a list of 
            expanded terms.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTerms(Lucene.Net.Search.Query)">
            <summary> Extracts all terms texts of a given Query into an array of WeightedTerms
            
            </summary>
            <param name="query">     Query to extract term texts from
            </param>
            <returns> an array of the terms used in a query, plus their weights.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetIdfWeightedTerms(Lucene.Net.Search.Query,Lucene.Net.Index.IndexReader,System.String)">
            <summary> Extracts all terms texts of a given Query into an array of WeightedTerms
            
            </summary>
            <param name="query">Query to extract term texts from</param>
            <param name="reader">used to compute IDF which can be used to a) score selected fragments better 
            b) use graded highlights eg chaning intensity of font color</param>
            <param name="fieldName">the field on which Inverse Document Frequency (IDF) calculations are based</param>
            <returns> an array of the terms used in a query, plus their weights.</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTerms(Lucene.Net.Search.Query,System.Boolean,System.String)">
            <summary>Extracts all terms texts of a given Query into an array of WeightedTerms</summary>
            <param name="query">Query to extract term texts from</param>
            <param name="prohibited"><c>true</c> to extract "prohibited" terms, too </param>
            <param name="fieldName"> The fieldName used to filter query terms</param>
            <returns>an array of the terms used in a query, plus their weights.</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTerms(Lucene.Net.Search.Query,System.Boolean)">
            <summary> Extracts all terms texts of a given Query into an array of WeightedTerms
            
            </summary>
            <param name="query">     Query to extract term texts from
            </param>
            <param name="prohibited"><c>true</c> to extract "prohibited" terms, too
            </param>
            <returns> an array of the terms used in a query, plus their weights.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.QueryTermExtractor.GetTermsFromBooleanQuery(Lucene.Net.Search.BooleanQuery,System.Collections.Generic.HashSet{Lucene.Net.Search.Highlight.WeightedTerm},System.Boolean,System.String)">
            <summary> extractTerms is currently the only query-independent means of introspecting queries but it only reveals
            a list of terms for that query - not the boosts each individual term in that query may or may not have.
            "Container" queries such as BooleanQuery should be unwrapped to get at the boost info held
            in each child element. 
            Some discussion around this topic here:
            http://www.gossamer-threads.com/lists/lucene/java-dev/34208?search_string=introspection;#34208
            Unfortunately there seemed to be limited interest in requiring all Query objects to implement
            something common which would allow access to child queries so what follows here are query-specific
            implementations for accessing embedded query elements. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleFragmenter">
            <summary> <see cref="T:Lucene.Net.Search.Highlight.IFragmenter"/> implementation which breaks text up into same-size 
            fragments with no concerns over spotting sentence boundaries.
            </summary>
            <author>  mark@searcharea.co.uk
            </author>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.SimpleFragmenter.FragmentSize">
            <summary>
            Gets or sets the size in number of characters of each fragment
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleHTMLEncoder">
            <summary> Simple <see cref="T:Lucene.Net.Search.Highlight.IEncoder"/> implementation to escape text for HTML output</summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SimpleHTMLFormatter">
            <summary> Simple <see cref="T:Lucene.Net.Search.Highlight.IFormatter"/> implementation to highlight terms with a pre and post tag</summary>
            <author>  MAHarwood
            
            </author>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleHTMLFormatter.#ctor">
            <summary> Default constructor uses HTML: &lt;B&gt; tags to markup terms
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.#ctor(Lucene.Net.Search.Highlight.QueryScorer)">
            <param name="queryScorer">QueryScorer that was used to score hits</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.#ctor(Lucene.Net.Search.Highlight.QueryScorer,System.Int32)">
            <param name="queryScorer">QueryScorer that was used to score hits</param>
            <param name="fragmentSize">size in bytes of each fragment</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.IsNewFragment">
            <seealso cref="M:Lucene.Net.Search.Highlight.IFragmenter.IsNewFragment"/>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.SimpleSpanFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)">
            <seealso cref="M:Lucene.Net.Search.Highlight.IFragmenter.Start(System.String,Lucene.Net.Analysis.TokenStream)"/>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.SpanGradientFormatter">
            <summary>
            Formats text with different color intensity depending on the score of the
            term using the span tag.  GradientFormatter uses a bgcolor argument to the font tag which
            doesn't work in Mozilla, thus this class.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Highlight.GradientFormatter"/>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TextFragment">
            <summary> Low-level class used to record information about a section of a document 
            with a score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TextFragment.Merge(Lucene.Net.Search.Highlight.TextFragment)">
            <summary></summary>
            <param name="frag2">Fragment to be merged into this one</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TextFragment.Follows(Lucene.Net.Search.Highlight.TextFragment)">
            <summary>
            true if this fragment follows the one passed
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TextFragment.ToString">
            <summary>
            Returns the marked-up text for this text fragment 
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TextFragment.FragNum">
            <summary>
            the fragment sequence number
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TokenGroup">
            <summary> One, or several overlapping tokens, along with the score(s) and the
            scope of the original text
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenGroup.GetToken(System.Int32)">
            <summary>
            the "n"th token
            </summary>
            <param name="index">a value between 0 and numTokens -1</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenGroup.GetScore(System.Int32)">
            <summary>
            the "n"th score
            </summary>
            <param name="index">a value between 0 and numTokens -1</param>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.EndOffset">
            <summary>
            the end position in the original text
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.StartOffset">
            <summary>
            The start position in the original text
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.TokenGroup.TotalScore">
            <summary>
            All tokens' scores summed up
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.TokenSources">
            <summary> Hides implementation issues associated with obtaining a TokenStream for use with
            the higlighter - can obtain from TermFreqVectors with offsets and (optionally) positions or
            from Analyzer class reparsing the stored content. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetAnyTokenStream(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary>
            A convenience method that tries to first get a TermPositionVector for the specified docId, then, falls back to
            using the passed in {@link org.apache.lucene.document.Document} to retrieve the TokenStream.  This is useful when
            you already have the document, but would prefer to use the vector first.
            </summary>
            <param name="reader">The <see cref="T:Lucene.Net.Index.IndexReader"/> to use to try and get the vector from</param>
            <param name="docId">The docId to retrieve.</param>
            <param name="field">The field to retrieve on the document</param>
            <param name="doc">The document to fall back on</param>
            <param name="analyzer">The analyzer to use for creating the TokenStream if the vector doesn't exist</param>
            <returns>The <see cref="T:Lucene.Net.Analysis.TokenStream"/> for the <see cref="T:Lucene.Net.Documents.IFieldable"/> on the <see cref="T:Lucene.Net.Documents.Document"/></returns>
            <exception cref="T:System.IO.IOException">if there was an error loading</exception>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetAnyTokenStream(Lucene.Net.Index.IndexReader,System.Int32,System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>
            A convenience method that tries a number of approaches to getting a token stream.
            The cost of finding there are no termVectors in the index is minimal (1000 invocations still 
            registers 0 ms). So this "lazy" (flexible?) approach to coding is probably acceptable
            </summary>
            <returns>null if field not stored correctly</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.TokenSources.GetTokenStream(Lucene.Net.Index.TermPositionVector,System.Boolean)">
            <summary>
            Low level api.
            Returns a token stream or null if no offset info available in index.
            This can be used to feed the highlighter with a pre-parsed token stream 
            
            In my tests the speeds to recreate 1000 token streams using this method are:
            - with TermVector offset only data stored - 420  milliseconds 
            - with TermVector offset AND position data stored - 271 milliseconds
             (nb timings for TermVector with position data are based on a tokenizer with contiguous
             positions - no overlaps or gaps)
            The cost of not using TermPositionVector to store
            pre-parsed content and using an analyzer to re-parse the original content: 
            - reanalyzing the original content - 980 milliseconds
            
            The re-analyze timings will typically vary depending on -
            	1) The complexity of the analyzer code (timings above were using a 
            	   stemmer/lowercaser/stopword combo)
             2) The  number of other fields (Lucene reads ALL fields off the disk 
                when accessing just one document field - can cost dear!)
             3) Use of compression on field storage - could be faster due to compression (less disk IO)
                or slower (more CPU burn) depending on the content.
            </summary>
            <param name="tpv"/>
            <param name="tokenPositionsGuaranteedContiguous">true if the token position numbers have no overlaps or gaps. If looking
            to eek out the last drops of performance, set to true. If in doubt, set to false.</param>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTerm">
            <summary>
            Lightweight class to hold term, Weight, and positions used for scoring this term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedTerm">
            <summary>
            Lightweight class to hold term and a Weight value used for scoring this term
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.WeightedTerm.Term">
            <summary>
            the term value (stemmed)
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Highlight.WeightedTerm.Weight">
            <summary>
            the Weight associated with this term
            </summary>
            <value> </value>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTerm.CheckPosition(System.Int32)">
            <summary>
            Checks to see if this term is valid at <c>position</c>.
            </summary>
            <param name="position">to check against valid term postions</param>
            <returns>true iff this term is a hit at this position</returns>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor">
            <summary>
            Class used to extract <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s from a <see cref="T:Lucene.Net.Search.Query"/> based on whether 
            <see cref="T:Lucene.Net.Index.Term"/>s from the <see cref="T:Lucene.Net.Search.Query"/> are contained in a supplied <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.Extract(Lucene.Net.Search.Query,System.Collections.Generic.IDictionary{System.String,Lucene.Net.Search.Highlight.WeightedSpanTerm})">
            <summary>
            Fills a <c>Map</c> with <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s using the terms from the supplied <c>Query</c>.
            </summary>
            <param name="query">Query to extract Terms from</param>
            <param name="terms">Map to place created WeightedSpanTerms in</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.ExtractWeightedSpanTerms(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Search.Highlight.WeightedSpanTerm},Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Fills a <c>Map</c> with <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s using the terms from the supplied <c>SpanQuery</c>.
            </summary>
            <param name="terms">Map to place created WeightedSpanTerms in</param>
            <param name="spanQuery">SpanQuery to extract Terms from</param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.ExtractWeightedTerms(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Search.Highlight.WeightedSpanTerm},Lucene.Net.Search.Query)">
            <summary>
            Fills a <c>Map</c> with <see cref="T:Lucene.Net.Search.Highlight.WeightedSpanTerm"/>s using the terms from the supplied <c>Query</c>.
            </summary>
            <param name="terms"></param>
            <param name="query"></param>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.FieldNameComparator(System.String)">
            <summary>
            Necessary to implement matches for queries against <c>defaultField</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.GetWeightedSpanTerms(Lucene.Net.Search.Query,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a Map of <c>WeightedSpanTerms</c> from the given <c>Query</c> and <c>TokenStream</c>.
            </summary>
            <param name="query">query that caused hit</param>
            <param name="tokenStream">TokenStream of text to be highlighted</param>
            <returns>Map containing WeightedSpanTerms</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.GetWeightedSpanTerms(Lucene.Net.Search.Query,Lucene.Net.Analysis.TokenStream,System.String)">
            <summary>
            Creates a Map of <c>WeightedSpanTerms</c> from the given <c>Query</c> and <c>TokenStream</c>.
            </summary>
            <param name="query">query that caused hit</param>
            <param name="tokenStream">tokenStream of text to be highlighted</param>
            <param name="fieldName">restricts Term's used based on field name</param>
            <returns>Map containing WeightedSpanTerms</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.GetWeightedSpanTermsWithScores(Lucene.Net.Search.Query,Lucene.Net.Analysis.TokenStream,System.String,Lucene.Net.Index.IndexReader)">
            <summary>
            Creates a Map of <c>WeightedSpanTerms</c> from the given <c>Query</c> and <c>TokenStream</c>. Uses a supplied
            <c>IndexReader</c> to properly Weight terms (for gradient highlighting).
            </summary>
            <param name="query">Query that caused hit</param>
            <param name="tokenStream">Tokenstream of text to be highlighted</param>
            <param name="fieldName">restricts Term's used based on field name</param>
            <param name="reader">to use for scoring</param>
            <returns>Map of WeightedSpanTerms with quasi tf/idf scores</returns>
        </member>
        <member name="M:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.SetWrapIfNotCachingTokenFilter(System.Boolean)">
            <summary>
            By default, <see cref="T:Lucene.Net.Analysis.TokenStream"/>s that are not of the type
            <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> are wrapped in a <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> to
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> impl and you don't want it to be wrapped, set this to
            false.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.PositionCheckingMap`1">
            <summary>
            This class makes sure that if both position sensitive and insensitive
            versions of the same term are added, the position insensitive one wins.
            </summary>
            <typeparam name="K"></typeparam>
        </member>
        <member name="T:Lucene.Net.Search.Highlight.WeightedSpanTermExtractor.FakeReader">
            <summary>
            A fake IndexReader class to extract the field from a MultiTermQuery
            </summary>
        </member>
    </members>
</doc>
